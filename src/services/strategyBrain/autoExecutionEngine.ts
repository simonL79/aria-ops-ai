
import { supabase } from '@/integrations/supabase/client';
import { executeStrategy } from './strategyExecutor';
import { predictStrategySuccess, PredictionMetrics } from './predictiveAnalytics';
import { ResponseStrategy } from './responseGenerator';
import { toast } from 'sonner';

export interface AutoExecutionConfig {
  entityName: string;
  autoExecutionEnabled: boolean;
  executionThresholds: {
    minSuccessProbability: number;
    maxRiskLevel: number;
    maxResourceRequirement: number;
    minConfidenceScore: number;
  };
  allowedStrategyTypes: string[];
  cooldownPeriod: number; // minutes
  maxDailyExecutions: number;
}

export interface ExecutionQueueItem {
  id: string;
  strategyId: string;
  entityName: string;
  scheduledAt: string;
  priority: number;
  autoGenerated: boolean;
  executionConfig: AutoExecutionConfig;
  predictionMetrics: PredictionMetrics;
  status: 'queued' | 'executing' | 'completed' | 'failed' | 'cancelled';
}

const defaultExecutionConfig: Partial<AutoExecutionConfig> = {
  autoExecutionEnabled: false,
  executionThresholds: {
    minSuccessProbability: 0.8,
    maxRiskLevel: 0.4,
    maxResourceRequirement: 0.6,
    minConfidenceScore: 0.7
  },
  allowedStrategyTypes: ['defensive', 'engagement'],
  cooldownPeriod: 60,
  maxDailyExecutions: 10
};

export const enableAutoExecution = async (
  entityName: string,
  config: Partial<AutoExecutionConfig> = {}
): Promise<void> => {
  try {
    const fullConfig: AutoExecutionConfig = {
      entityName,
      ...defaultExecutionConfig,
      ...config
    } as AutoExecutionConfig;

    await supabase.from('aria_ops_log').insert({
      operation_type: 'auto_execution_config',
      module_source: 'auto_execution_engine',
      success: true,
      entity_name: entityName,
      operation_data: fullConfig as any
    });

    console.log(`ü§ñ Auto-execution enabled for ${entityName}`);
    toast.success(`Auto-execution enabled for ${entityName}`);

  } catch (error) {
    console.error('Failed to enable auto-execution:', error);
    throw error;
  }
};

export const evaluateForAutoExecution = async (
  strategy: ResponseStrategy,
  entityName: string
): Promise<boolean> => {
  try {
    // Get auto-execution config for entity
    const config = await getAutoExecutionConfig(entityName);
    if (!config || !config.autoExecutionEnabled) return false;

    // Check daily execution limit
    const dailyCount = await getDailyExecutionCount(entityName);
    if (dailyCount >= config.maxDailyExecutions) {
      console.log(`üö´ Daily execution limit reached for ${entityName}`);
      return false;
    }

    // Check cooldown period
    const lastExecution = await getLastExecutionTime(entityName);
    if (lastExecution && isInCooldown(lastExecution, config.cooldownPeriod)) {
      console.log(`‚è±Ô∏è Cooldown period active for ${entityName}`);
      return false;
    }

    // Check if strategy type is allowed
    if (!config.allowedStrategyTypes.includes(strategy.type)) {
      console.log(`üö´ Strategy type ${strategy.type} not allowed for auto-execution`);
      return false;
    }

    // Run predictive analysis
    const prediction = await predictStrategySuccess(strategy, entityName);
    const metrics = prediction.metrics;

    // Check against thresholds
    const thresholds = config.executionThresholds;
    
    if (metrics.successProbability < thresholds.minSuccessProbability) {
      console.log(`üö´ Success probability too low: ${metrics.successProbability}`);
      return false;
    }

    if (metrics.riskLevel > thresholds.maxRiskLevel) {
      console.log(`üö´ Risk level too high: ${metrics.riskLevel}`);
      return false;
    }

    if (metrics.resourceRequirement > thresholds.maxResourceRequirement) {
      console.log(`üö´ Resource requirement too high: ${metrics.resourceRequirement}`);
      return false;
    }

    if (metrics.confidenceScore < thresholds.minConfidenceScore) {
      console.log(`üö´ Confidence score too low: ${metrics.confidenceScore}`);
      return false;
    }

    console.log(`‚úÖ Strategy ${strategy.id} approved for auto-execution`);
    return true;

  } catch (error) {
    console.error('Auto-execution evaluation failed:', error);
    return false;
  }
};

export const queueForAutoExecution = async (
  strategy: ResponseStrategy,
  entityName: string,
  priority: number = 5
): Promise<string> => {
  try {
    const config = await getAutoExecutionConfig(entityName);
    const prediction = await predictStrategySuccess(strategy, entityName);

    const queueItem: ExecutionQueueItem = {
      id: `auto-exec-${Date.now()}`,
      strategyId: strategy.id,
      entityName,
      scheduledAt: new Date().toISOString(),
      priority,
      autoGenerated: true,
      executionConfig: config!,
      predictionMetrics: prediction.metrics,
      status: 'queued'
    };

    // Store in execution queue
    await supabase.from('aria_ops_log').insert({
      operation_type: 'execution_queue',
      module_source: 'auto_execution_engine',
      success: true,
      entity_name: entityName,
      operation_data: queueItem as any
    });

    // Execute immediately if high priority
    if (priority <= 2) {
      setTimeout(() => processExecutionQueue(), 1000);
    }

    console.log(`üìã Strategy queued for auto-execution: ${queueItem.id}`);
    return queueItem.id;

  } catch (error) {
    console.error('Failed to queue for auto-execution:', error);
    throw error;
  }
};

export const processExecutionQueue = async (): Promise<void> => {
  try {
    console.log('üîÑ Processing auto-execution queue...');

    // Get queued items (in a real implementation, this would be from a dedicated table)
    const { data: queueData } = await supabase
      .from('aria_ops_log')
      .select('*')
      .eq('operation_type', 'execution_queue')
      .order('created_at', { ascending: true })
      .limit(5);

    if (!queueData || queueData.length === 0) return;

    for (const item of queueData) {
      const queueItem = item.operation_data as ExecutionQueueItem;
      
      if (queueItem.status !== 'queued') continue;

      try {
        // Update status to executing
        queueItem.status = 'executing';
        await updateQueueItemStatus(item.id, queueItem);

        // Execute the strategy
        const result = await executeStrategy(queueItem.strategyId);

        // Update status based on result
        queueItem.status = result.success ? 'completed' : 'failed';
        await updateQueueItemStatus(item.id, queueItem);

        console.log(`‚úÖ Auto-executed strategy ${queueItem.strategyId}: ${queueItem.status}`);
        
        toast.success(`Auto-executed strategy: ${result.message}`);

      } catch (error) {
        queueItem.status = 'failed';
        await updateQueueItemStatus(item.id, queueItem);
        console.error(`‚ùå Auto-execution failed for ${queueItem.strategyId}:`, error);
      }
    }

  } catch (error) {
    console.error('Queue processing failed:', error);
  }
};

const getAutoExecutionConfig = async (entityName: string): Promise<AutoExecutionConfig | null> => {
  try {
    const { data } = await supabase
      .from('aria_ops_log')
      .select('*')
      .eq('operation_type', 'auto_execution_config')
      .eq('entity_name', entityName)
      .order('created_at', { ascending: false })
      .limit(1);

    return data?.[0]?.operation_data as AutoExecutionConfig || null;
  } catch (error) {
    console.error('Failed to get auto-execution config:', error);
    return null;
  }
};

const getDailyExecutionCount = async (entityName: string): Promise<number> => {
  try {
    const today = new Date();
    today.setHours(0, 0, 0, 0);

    const { data } = await supabase
      .from('aria_ops_log')
      .select('id')
      .eq('operation_type', 'execution_queue')
      .eq('entity_name', entityName)
      .gte('created_at', today.toISOString());

    return data?.length || 0;
  } catch (error) {
    console.error('Failed to get daily execution count:', error);
    return 0;
  }
};

const getLastExecutionTime = async (entityName: string): Promise<Date | null> => {
  try {
    const { data } = await supabase
      .from('strategy_responses')
      .select('executed_at')
      .eq('entity_name', entityName)
      .not('executed_at', 'is', null)
      .order('executed_at', { ascending: false })
      .limit(1);

    return data?.[0]?.executed_at ? new Date(data[0].executed_at) : null;
  } catch (error) {
    console.error('Failed to get last execution time:', error);
    return null;
  }
};

const isInCooldown = (lastExecution: Date, cooldownMinutes: number): boolean => {
  const now = new Date();
  const cooldownEnd = new Date(lastExecution.getTime() + cooldownMinutes * 60 * 1000);
  return now < cooldownEnd;
};

const updateQueueItemStatus = async (logId: string, queueItem: ExecutionQueueItem): Promise<void> => {
  try {
    await supabase
      .from('aria_ops_log')
      .update({ operation_data: queueItem as any })
      .eq('id', logId);
  } catch (error) {
    console.error('Failed to update queue item status:', error);
  }
};

// Auto-execution monitor that runs periodically
export const startAutoExecutionMonitor = (): NodeJS.Timeout => {
  return setInterval(() => {
    processExecutionQueue();
  }, 30000); // Process queue every 30 seconds
};
